---
output:
  github_document
---


```{r, echo = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "README-"
)
options(width = 110)

```

# SocSci: Functions for Analyzing Survey Data

## Author

Ryan Burge â€” <https://www.ryanburge.net>  
Reference site: <https://ryanburge.github.io/socsci/>

Professor of Practice, Washington University in St. Louis


------

### Installation

You can install:

* the latest development version from GitHub with

    ```R
    install.packages("devtools")
    devtools::install_github("ryanburge/socsci")
    ```
    
## There are just a handful of functions to the package right now 


## Counting Things

I love the functionality of tabyl, but it doesn't take a weight variable. Here's the simple version `ct()`

```{r, warning = FALSE, message = FALSE}
library(socsci)

df <- tibble::tibble(
  race   = c("White", "Black", "Hispanic", "Asian", NA, "White", "Black"),
  weight = c(1, 1.2, 0.8, 1.5, 1, 1, 0.9)
)

# Unweighted
df %>% ct(race)
# Weighted
df %>% ct(race, wt = weight)
# Exclude NAs before computing pct
df %>% ct(race, show_na = FALSE)
# Cumulative totals (sorted by frequency)
df %>% ct(race, wt = weight, show_na = FALSE, cum = TRUE, sort = TRUE)

```



## Getting Confidence Intervals

Oftentimes in social science we like to see what our 95% confidence intervals are, but that's a lot of syntax. It's easy with the `mean_ci` function. 


```{r, warning = FALSE, message = FALSE}
set.seed(1)
df2 <- tibble::tibble(
  x  = c(rnorm(8, 10, 2), NA_real_),
  w  = c(1, 2, 1, 1, 2, 1, 1, 3, 1)
)

# Unweighted, 95% CI (t critical)
mean_ci(df2, x)

# Unweighted, 90% CI (normal critical)
mean_ci(df2, x, ci = 0.90, dist = "normal")

# Weighted, 95% CI
mean_ci(df2, x, wt = w)

# Weighted, 84% CI (often used for visual comparison)
mean_ci(df2, x, wt = w, ci = 0.84)

```



## Recode things and keep the factor levels 

I recode all the time, but unfortunately when you recode from numeric to character the factor levels are plotted in alphabetical order. There's a way around that now. This uses the `case_when` function from `dplyr` but makes sure that the factors level are the same order of how they are specified in the function.


```{r, warning = FALSE, message = FALSE, fig.width= 12, fig.show="hide"}
df3 <- tibble::tibble(
  pid7 = c(1,2,3,4,5,6,7, NA, 4, 2)
)

df3 %>%
  mutate(
    pid_new = frcode(
      pid7 == 1 ~ "Strong Democrat",
      pid7 == 2 ~ "Not Strong Democrat",
      pid7 == 3 ~ "Lean Democrat",
      pid7 == 4 ~ "Independent",
      pid7 == 5 ~ "Lean Republican",
      pid7 == 6 ~ "Not Strong Republican",
      pid7 == 7 ~ "Strong Republican",
      TRUE ~ NA_character_
    )
  ) %>%
  ct(pid_new, show_na = FALSE)
```



